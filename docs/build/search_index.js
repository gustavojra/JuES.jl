var documenterSearchIndex = {"docs":
[{"location":"backend.html#Backend-1","page":"Backend","title":"Backend","text":"","category":"section"},{"location":"backend.html#Wavefunction.jl-1","page":"Backend","title":"Wavefunction.jl","text":"","category":"section"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"Wavefunction.jl defines the Wfn type and constructors. These constructors take in a Psi4 wavefunction object (PyObject) and convert necessary information to Julia data structures.","category":"page"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.Wavefunction","category":"page"},{"location":"backend.html#JuES.Wavefunction","page":"Backend","title":"JuES.Wavefunction","text":"Module for storing and handling reference wavefunctions.\n\nstructs\n\nWfn -> holds info for disk based and in core computations.\nDirectWfn -> holds info for integral direct computations.\n\n\n\n\n\n","category":"module"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.Wavefunction.Wfn(wfn)","category":"page"},{"location":"backend.html#JuES.Wavefunction.Wfn-Tuple{Any}","page":"Backend","title":"JuES.Wavefunction.Wfn","text":"Wfn{T}(wfn::PyObject; unrestricted::Bool=false, diskbased::Bool=false, name::String = \"default\", df::Bool=false) where T\n\n\n\n\n\n","category":"method"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.Wavefunction.Wfn","category":"page"},{"location":"backend.html#JuES.Wavefunction.Wfn","page":"Backend","title":"JuES.Wavefunction.Wfn","text":"Wfn\n\nData structure for storing integrals, MO coefficients, and misc information about a reference (HF) wavefunction.\n\nFields\n\nnalpha::Int number of alpha electrons\n\nnbeta::Int number of beta electrons\n\nnvira::Int number of virtual functions of alpha spin\n\nnvirb::Int number of virtual functions of beta spin\n\nnmo::Int number of molecular orbitals\n\nunrestricted::Bool whether or not the alpha and beta spatial extents are required to be the same.\n\nCa::Array{T,2} AO->MO coefficients for alpha MO's\n\nCb::Array{T,2} AO->MO coefficients for beta MO's\n\nhao::Array{T,2} AO basis core hamiltonian (kinetic + potential)\n\nepsa::Array{T,1} orbital eigenvalues for alpha MO's\n\nepsb::Array{T,1} orbtial eigenvalues for beta MO's\n\nao_eri::Union{Array{T,4},DiskFourTensor} AO basis TEI\n\npqrs::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case AAAA)\n\npQrS::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case ABAB)\n\npQRs::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case ABBA)\n\nPQRS::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case BBBB)\n\nPqRs::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case BABA)\n\nPqrS::Union{Array{T,4},DiskFourTensor} MO basis TEI (spin case BAAB)\n\n\n\n\n\n","category":"type"},{"location":"backend.html#Transformation.jl-1","page":"Backend","title":"Transformation.jl","text":"","category":"section"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.Transformation","category":"page"},{"location":"backend.html#IntegralTransformation.jl-1","page":"Backend","title":"IntegralTransformation.jl","text":"","category":"section"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"This module contain functions used to convert AO integrals into MO integrals. It can be used to get ERI arrays and Fock matrices.","category":"page"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.IntegralTransformation","category":"page"},{"location":"backend.html#JuES.IntegralTransformation","page":"Backend","title":"JuES.IntegralTransformation","text":"JuES.IntegralTransformation\n\nModule to handle integral transformations from AO to MO.\n\nFunctions:\n\nget_eri   From a Wavefunction object, return a specified ERI array.\nget_fock  From a Wavefunction object, return the Fock matrix.\n\n\n\n\n\n","category":"module"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.IntegralTransformation.get_eri","category":"page"},{"location":"backend.html#JuES.IntegralTransformation.get_eri","page":"Backend","title":"JuES.IntegralTransformation.get_eri","text":"JuES.IntegralTransformation.get_eri(wfn::Wfn, eri_string::String, notation::String = \"phys\")\n\nFrom a Wavefunction object, return a specified ERI array.\n\nArguments\n\nwfn         Wavefunction object.\neri_string  String with length 4 identifying the type of ERI. \n            Characters must be (o, O, v, V). Each indicating \n            Occupied and Virtual for ALPHA and beta.\n\nKwargs\n\nnotation    {\"chem\", \"phys\"}\n            Return the array in Chemist's or Physicists' notation.\n            Default: \"phys\".\n\n\n\n\n\n","category":"function"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.IntegralTransformation.get_fock","category":"page"},{"location":"backend.html#JuES.IntegralTransformation.get_fock","page":"Backend","title":"JuES.IntegralTransformation.get_fock","text":"JuES.IntegralTransformation.get_fock(wfn::Wfn, spin::String = \"alpha\")\n\nFrom a Wavefunction object, return the Fock matrix.\n\nArguments\n\nwfn  Wavefunction object.\n\nKwargs\n\nspin    {\"alpha\", \"a\", \"up\", \"beta\", \"b\", \"down\"}\n        String indicating the spin of the Fock matrix. \n        Case insensitive.\n\n\n\n\n\n","category":"function"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.Transformation.tei_transform","category":"page"},{"location":"backend.html#JuES.Transformation.tei_transform","page":"Backend","title":"JuES.Transformation.tei_transform","text":"tei_transform(\n              gao::Union{Array{Float64,4},Array{Float32,4}},\n              C1::Union{Array{Float64,2},Array{Float32,2}},\n              C2::Union{Array{Float64,2},Array{Float32,2}},\n              C3::Union{Array{Float64,2},Array{Float32,2}},\n              C4::Union{Array{Float64,2},Array{Float32,2}},\n              name::String\n              )\n\nTransform gao to the MO basis defined by C1,C2,C3,C4. \n\n\n\n\n\n","category":"function"},{"location":"backend.html#DF.jl-1","page":"Backend","title":"DF.jl","text":"","category":"section"},{"location":"backend.html#","page":"Backend","title":"Backend","text":"JuES.DF","category":"page"},{"location":"backend.html#JuES.DF","page":"Backend","title":"JuES.DF","text":"Module for Density Fitting (DF) utility routines\n\nexports: functions     setup_df\n\n\n\n\n\n","category":"module"},{"location":"cc.html#Coupled-Cluster-1","page":"Coupled Cluster","title":"Coupled Cluster","text":"","category":"section"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster","category":"page"},{"location":"cc.html#JuES.CoupledCluster","page":"Coupled Cluster","title":"JuES.CoupledCluster","text":"Module for running CC computations in Julia.\n\nImplemented –> RCCD, RCCSD, DF-RCCD\n\n\n\n\n\n","category":"module"},{"location":"cc.html#CCD-1","page":"Coupled Cluster","title":"CCD","text":"","category":"section"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.RCCD","category":"page"},{"location":"cc.html#JuES.CoupledCluster.RCCD","page":"Coupled Cluster","title":"JuES.CoupledCluster.RCCD","text":"JuES.CoupledCluster.RCCD\n\nperforms coupled cluster doubles (CCD) computations.\n\nFunctions\n\nJuES.CoupledCluster.RCCD.do_rccd\n\n\n\n\n\n","category":"module"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.RCCD.do_rccd","category":"page"},{"location":"cc.html#JuES.CoupledCluster.RCCD.do_rccd","page":"Coupled Cluster","title":"JuES.CoupledCluster.RCCD.do_rccd","text":"do_rccd\n\nApplies RCCD equations to the input Wfn object. Disk based versus in-core  algorithm is selected based on the type of atomic orbitals in Wfn.uvsr. –-\n\nparamters\n\nrefWfn::Wfn         -> Wfn object to which the RCCD equations will be applied.\n\nmaxit::Int          -> maximum number of coupled cluster iterations.\n\ndoprint::Bool=false -> whether or not to print energy and timing information to      stdout.\n\noutput\n\nccenergy::Float -> final RCCD energy. \n\n\n\n\n\n","category":"function"},{"location":"cc.html#CCSD-1","page":"Coupled Cluster","title":"CCSD","text":"","category":"section"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.RCCSD","category":"page"},{"location":"cc.html#JuES.CoupledCluster.RCCSD","page":"Coupled Cluster","title":"JuES.CoupledCluster.RCCSD","text":"JuES.CoupledCluster.RCCSD\n\nFunctions\n\nJuES.CoupledCluster.RCCSD.do_rccsd\n\n\n\n\n\n","category":"module"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.RCCSD.do_rccsd","category":"page"},{"location":"cc.html#JuES.CoupledCluster.RCCSD.do_rccsd","page":"Coupled Cluster","title":"JuES.CoupledCluster.RCCSD.do_rccsd","text":"JuES.CoupledCluster.RCCSD.do_rccsd(refWfn::Wfn; kwargs...)\n\nArguments\n\nrefWfn::Wfn\n\nreference wavefunction to compute RCCSD on.\n\nkwargs::Any\n\nkeyword arguments for various options.\n\nKwargs\n\n:doprint::Bool  print or no? deprecated\n:maxit::Int     max number of iterations for RCCSD equations\n:return_T::Bool do return the converged cluster amplitudes?\n:diis::Bool     do DIIS extrapolation? currently dummy\n\n\n\n\n\n","category":"function"},{"location":"cc.html#AutoRCCSD-1","page":"Coupled Cluster","title":"AutoRCCSD","text":"","category":"section"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"Module that performs Restricted CCSD using auto factorized equations.","category":"page"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.AutoRCCSD","category":"page"},{"location":"cc.html#JuES.CoupledCluster.AutoRCCSD","page":"Coupled Cluster","title":"JuES.CoupledCluster.AutoRCCSD","text":"JuES.CoupledCluster.AutoRCCSD\n\nModule that performs Restricted CCSD using auto factorized equations.\n\nFunctions:\n\nupdate_energy   Compute CC energy from amplitudes arrays.\nupdate_amp      Update produces new set of amplitudes from old ones. \ndo_rccsd        Compute RCCSD.\n\n\n\n\n\n","category":"module"},{"location":"cc.html#","page":"Coupled Cluster","title":"Coupled Cluster","text":"JuES.CoupledCluster.AutoRCCSD.update_energy","category":"page"},{"location":"cc.html#JuES.CoupledCluster.AutoRCCSD.update_energy","page":"Coupled Cluster","title":"JuES.CoupledCluster.AutoRCCSD.update_energy","text":"JuES.CoupledCluster.AutoRCCSD.update_energy(T1::Array{Float64, 2}, T2::Array{Float64, 4}, f::Array{Float64,2}, Voovv::Array{Float64, 4})\n\nCompute CC energy from amplitudes arrays.\n\nArguments\n\nT1    T1 CC amplitudes array.\nT2    T2 CC amplitudes array.\nf     Fock matrix fia\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuES-documentation-1","page":"JuES documentation","title":"JuES documentation","text":"","category":"section"},{"location":"index.html#","page":"JuES documentation","title":"JuES documentation","text":"Welcome to the documentation for JuES. See the hamburger menu for more details.","category":"page"}]
}
